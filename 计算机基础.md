# 内存空间有限，那如何容纳超出内存容量大小的应用运行  
- 虚拟内存 
- 按需分页  
- 页面置换  
- 内存映射  
- 分块处理  

# 内存页面置换算法  
- OPT：置换未来最长时间内不会被访问的页面。
- FIFO：最早进入内存的页面最先被淘汰。
- LRU：最近最少使用
- LFU：最不常用
- MRU：最近最常被使用  

# 内存页式、段式、段页式
- 页：将内存按照固定大小的“页”划分，通过页表把逻辑页映射到物理页框
- 段：将进程按逻辑单位划分为段，每段大小可变，段表、逻辑段保护
- 段页：在段的基础上，每段内部按页分页，“段”管理逻辑与保护，“页”管理物理分配与碎片。

# 编译过程
源代码 → 词法分析 → 语法分析 → 语义分析 → 中间代码生成 → 优化 → 目标代码生成
对于c编译过程  
1. 预处理：展开头文件，处理宏，删除注释
2. 编译：词法分析语法分析，生产汇编代码  
3. 汇编：汇编器把汇编指令转换成机器指令（二进制），生成目标文件（但还没与库链接）
4. 链接：将多个 .o 文件合并，解析外部符号（比如库函数 printf）生成最终的可执行文件
# 词法分析（Lexing/Scanning）
- 把源代码中的字符流（字符序列），转换为记号（Token）流。词法分析解决“一个个单词是什么”；
# 语法分析（Parsing）
- 根据一系列 Token，按照语言的语法规则（文法），构建出程序的语法树。语法分析解决“这些单词能不能组成一句正确的语句”。  

# 动态库与静态库  
- 静态库   
链接期被合入生成物中，运行时不依赖库文件；
- 动态库  
动态库在运行时被加载并绑定，运行时依赖库文件的存在与版本。

# C语言如何检测系统32位还是64位  
- 使用预处理器宏
- 使用指针大小
指针为 4 字节意味着 32 位进程，指针为 8 字节意味着 64 位进程。通过 sizeof 判断当前进程是

# 堆栈 
- 栈由系统自动管理，结构是先进后出，内存连续，速度非常快，主要存储函数相关内容。
- 堆由程序员手动管理，内存不连续，系统通过“空闲链表”管理，生命周期由程序员控制，存储运行时动态分配的对象或数组
- 栈存储快而短暂，堆存储慢而灵活    

