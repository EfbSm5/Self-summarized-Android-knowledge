Jvav 基础

死锁原因：
互斥条件（Mutual Exclusion）
资源在任意时刻只能被一个进程使用。其他请求该资源的进程必须等待。
请求与保持条件（Hold and Wait）：
进程已经持有至少一个资源，但又提出了新的资源请求，而该新资源已被其他进程占有。此时，该进程被阻塞，但它并不释放自己已持有的资源。
不可剥夺条件（No Preemption）：
进程已获得的资源，在未使用完之前，不能被其他进程强行剥夺，只能由该进程主动释放。
循环等待条件（Circular Wait）：
存在一种进程资源的循环等待链。链中的每一个进程都在等待下一个进程所持有的资源。

synchronized和lock的区别
syschronized是jvm层面实现，可以自动释放，不可中断，非公平，更原始
lock是api层面，可以手动中断，可以非阻塞获取锁，超时获取锁，
synchronized是jvm实现，所以是系统管理，不需要手动释放，lock是程序员管理，需要手动释放，lock可以按照时间等，synchronized只会一直等。lock可以先来后到，synchronized不行，lock可以condition
一般优先用synchronized，简洁不出错，当需要非阻塞的获取锁，响应中断地获取锁，超时获取锁，需要公平锁，有condition
同步锁
synchronized 是通过jvm的对象头进行处理并发，jvm锁有一个升级过程

jni调用c代码
两个部分，java调用c函数，c回调java 访问java字段
java先native声明，System.loadLibrary("hello")实现调用
javac -h生成头文件
c实现头文件函数
c编译成动态链接库

c会传入一系列jni类型，会通过一些方法进行处理。对于一些基础类型，可以直接使用，但是一些引用类型需要进行转化，比如GetStringUTFChars

类加载：
加载 将类文件加载进内存中，生成一个Class对象
验证 JVM 会在该阶段对二进制字节流进行校验，只有符合 JVM 字节码规范的才能被 JVM 正确执行。该阶段是保证 JVM 安全的重要屏障
准备 对类变量（也称为静态变量，static 关键字修饰的）分配内存并初始化
解析 该阶段将常量池中的符号引用转化为直接引用。
初始化 执行init方法，给static赋值

Exception和Error的区别？
两者都继承了Throwable类，
Error类描述Java运行时系统内部的错误，Error一般都会导致程序处于非正常，不可恢复的状态，不便于捕捉
Exception分解为两个分支：RuntimeException,其他异常，由程序错误导致的异常属于RuntimeException；而程序本身没有问题，但由于像I/O错误这类问题导致的异常属于其他异常。

String 不可变，线程安全，每次操作都会生成新的String对象，性能低
StringBuilder 可变，没有线程安全，性能高
StringBuffer 可变，线程安全，性能相对低

final形容类，属性，方法，其表示不能重新赋值，不可以继承，不可以重写
finally是try catch结束后必定调用的
finalize是析构函数

int是基本类型，intenger是类的对象，性能更弱，可以支持方法，可以泛型，需要null,集合，泛型，反射，框架用

==比较是否是同一个对象或者和基本值是否相同
equals默认是引用是否是相同，一些类重写后表示逻辑内容相同
hashcode是计算其哈希值，需要保证当equals返回为true,必须要保证hashcode相同，hashCode 与 equals 的核心关系是：equals 判定逻辑相等；hashCode 决定哈希桶位置。Java 规定：如果两个对象 equals 为 true，hashCode 必须相等；反之不要求。违反会导致 HashMap/HashSet 查找、去重异常。实现时只把定义对象逻辑身份的不可变字段纳入二者，重写 equals 必须同步重写 hashCode，并保持与 compareTo 语义尽量一致。

static主要就是保证内存里只有一份，假如是变量就只会在不同类的实例中共享一个值，如果是静态方法就是不依靠实例状态的操作，静态的代码块一次性初始化，接口中的静态方法不会被类继承，

重写override 是多态的体现
重载是换参数，提供一个不同参数的调用方法

Java集合
Collection有 list set quene
Map 有SortedMap

Runnable和Thread有什么区别？
Runnable 关注“做什么”——业务逻辑，这是一个接口
Thread 关注“在哪个独立执行流里跑”——调度、生命周期、线程控制，thread是一个类
好处：任务与执行策略解耦 → 可以把任务提交给不同的执行环境（Thread、线程池、定时器）
runnable也可以被不同线程复用

静态方法，静态内部类，不能访问类非静态的属性和方法，内部类可以但是依赖一个外部类实例

ThreadPoolExecutor 通过 三步策略（先核心、再排队、再非核心）+ 有界队列 + 拒绝策略 控制并发，核心线程是基础常驻执行单元，非核心用于峰值扩展；任务调度依赖阻塞队列，线程回收取决于 keepAliveTime 与 allowCoreThreadTimeOut，默认 Executors 一些工厂方法有无界风险，最佳实践是手动显式参数化创建。

Arraylist扩容
HashMap数据结构存储机制
LRU
java内存模型
