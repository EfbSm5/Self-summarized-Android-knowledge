# 内存空间有限，那如何容纳超出内存容量大小的应用运行  
- 虚拟内存 
- 按需分页  
- 页面置换  
- 内存映射  
- 分块处理  

# 虚拟内存  
虚拟内存是操作系统提供的一层抽象，它为每个进程提供一个连续的从零开始的虚拟地址空间，让进程像拥有独立的大内存一样编程而不需要真实布局。

# 内存页面置换算法  
- OPT：置换未来最长时间内不会被访问的页面。
- FIFO：最早进入内存的页面最先被淘汰。
- LRU：最近最少使用
- LFU：最不常用
- MRU：最近最常被使用  

# 内存页式、段式、段页式
- 页：将内存按照固定大小的“页”划分，通过页表把逻辑页映射到物理页框
- 段：将进程按逻辑单位划分为段，每段大小可变，段表、逻辑段保护
- 段页：在段的基础上，每段内部按页分页，“段”管理逻辑与保护，“页”管理物理分配与碎片。

# 编译过程
源代码 → 词法分析 → 语法分析 → 语义分析 → 中间代码生成 → 优化 → 目标代码生成
对于c编译过程  
1. 预处理：展开头文件，处理宏，删除注释
2. 编译：词法分析语法分析，生产汇编代码  
3. 汇编：汇编器把汇编指令转换成机器指令（二进制），生成目标文件（但还没与库链接）
4. 链接：将多个 .o 文件合并，解析外部符号（比如库函数 printf）生成最终的可执行文件

# 词法分析（Lexing/Scanning）
- 把源代码中的字符流（字符序列），转换为记号（Token）流。词法分析解决“一个个单词是什么”；

# 语法分析（Parsing）
- 根据一系列 Token，按照语言的语法规则（文法），构建出程序的语法树。语法分析解决“这些单词能不能组成一句正确的语句”。  

# 动态库与静态库  
- 静态库   
链接期被合入生成物中，运行时不依赖库文件；
- 动态库  
动态库在运行时被加载并绑定，运行时依赖库文件的存在与版本。

# C语言如何检测系统32位还是64位  
- 使用预处理器宏
- 使用指针大小
指针为 4 字节意味着 32 位进程，指针为 8 字节意味着 64 位进程。通过 sizeof 判断当前进程是

# 堆栈 
- 栈由系统自动管理，结构是先进后出，内存连续，速度非常快，主要存储函数相关内容。
- 堆由程序员手动管理，内存不连续，系统通过“空闲链表”管理，生命周期由程序员控制，存储运行时动态分配的对象或数组
- 栈存储快而短暂，堆存储慢而灵活    

# 用户态和内核态  
- 用户态（User Mode）  
    应用程序运行的特权级，权限受限，不能直接访问硬件或关键内核数据结构。通过系统调用接口向内核请求服务（文件、网络、进程、内存等）。
- 内核态（Kernel Mode）  
操作系统内核运行的高特权级，能访问所有硬件资源与内存地址空间。负责进程/线程调度、内存管理、文件系统、设备驱动、中断处理等。 
- 为什么分这个  
    1. 安全性：防止普通应用直接操作硬件或破坏系统结构。
   2.  稳定性：应用出错不会直接破坏内核；内核可隔离故障。
    3. 抽象与可移植性：应用使用统一的系统调用/库接口，无需关心具体硬件细节。

# IO操作  
- 发起 I/O 通常需要系统调用，CPU 会从用户态陷入内核态，由内核进行权限检查、页缓存/协议栈处理与驱动交互；等待期间线程会被挂起，CPU 不会一直忙等。
- I/O 之所以设计为系统调用，是因为需要安全隔离、统一的资源管理与抽象，以及硬件访问必须在高特权级完成；同时内核还能通过缓存、DMA、异步中断等提升整体性能。如果在用户态，任何程序都可能破坏系统窃取数据。

# CPU 调度算法（时间片、优先级、抢占）
- 时间片  
系统给每个任务分配了一个固定时间片，在到时间后切换到下一个任务，没有完成的重新进行排队，其响应速度快，每个任务都可以执行，但是频繁切换导致开销。
- 优先级  
按优先级执行，高优先级任务先执行。
- 抢占  
操作系统可随时打断当前任务  

# Linux 文件系统  
无论是磁盘文件、设备（如摄像头、声卡）、还是进程通信管道、网络 socket，对操作系统而言——它们都是文件。
- VFS  
    Virtual File System是 Linux 内核中一个抽象层，统一管理各种类型的文件系统，为不同设备提供统一接口  

# Linux进程创建过程  
在 Linux 中，创建一个新进程其实分两步：
1. 复制父进程（fork）
复制当前进程，创建一个几乎完全一样的子进程。子进程几乎与父进程完全一样（代码、数据、堆、栈、打开的文件描述符都复制），只有进程PID不同。
2. 执行新程序（exec）
用新的程序替换当前进程的内存空间。它不会创建新进程，只是把当前进程的内容替换成一个新的可执行文件。  
- 它允许灵活控制共享内容（内存空间、文件、信号等），也是线程的底层实现。